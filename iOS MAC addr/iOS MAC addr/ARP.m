//
//  ARP.m
//  iOS MAC addr
//
//  Created by TUTU on 2017/2/28.
//  Copyright © 2017年 TUTU. All rights reserved.
//

#import "ARP.h"
#import "Address.h"
#import <sys/socket.h>
#import <sys/sysctl.h>
#import <sys/ioctl.h>
#import <net/if.h>
#import <net/if_dl.h>
#import <netinet/in.h>

/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */
struct rt_metrics {
    u_int32_t	rmx_locks;	/* Kernel leaves these values alone */
    u_int32_t	rmx_mtu;	/* MTU for this path */
    u_int32_t	rmx_hopcount;	/* max hops expected */
    int32_t		rmx_expire;	/* lifetime for route, e.g. redirect */
    u_int32_t	rmx_recvpipe;	/* inbound delay-bandwidth product */
    u_int32_t	rmx_sendpipe;	/* outbound delay-bandwidth product */
    u_int32_t	rmx_ssthresh;	/* outbound gateway buffer limit */
    u_int32_t	rmx_rtt;	/* estimated round trip time */
    u_int32_t	rmx_rttvar;	/* estimated rtt variance */
    u_int32_t	rmx_pksent;	/* packets sent using this route */
    u_int32_t	rmx_filler[4];	/* will be used for T/TCP later */
};

/*
 * Structures for routing messages.
 */
struct rt_msghdr {
    u_short	rtm_msglen;	/* to skip over non-understood messages */
    u_char	rtm_version;	/* future binary compatibility */
    u_char	rtm_type;	/* message type */
    u_short	rtm_index;	/* index for associated ifp */
    int	rtm_flags;	/* flags, incl. kern & message, e.g. DONE */
    int	rtm_addrs;	/* bitmask identifying sockaddrs in msg */
    pid_t	rtm_pid;	/* identify sender */
    int	rtm_seq;	/* for sender to identify action */
    int	rtm_errno;	/* why failed */
    int	rtm_use;	/* from rtentry */
    u_int32_t rtm_inits;	/* which metrics we are initializing */
    struct rt_metrics rtm_rmx; /* metrics themselves */
};

struct sockaddr_inarp {
    u_char	sin_len;
    u_char	sin_family;
    u_short sin_port;
    struct	in_addr sin_addr;
    struct	in_addr sin_srcaddr;
    u_short	sin_tos;
    u_short	sin_other;
#define	SIN_PROXY	0x1
#define	SIN_ROUTER	0x2
};

#ifndef SA_SIZE
#define SA_SIZE(sa)                                             \
(  (!(sa) || ((struct sockaddr *)(sa))->sa_len == 0) ?      \
sizeof(uint32_t)            :                               \
1 + ( (((struct sockaddr *)(sa))->sa_len - 1) | (sizeof(uint32_t) - 1) ) )
#endif

@implementation ARP

+ (nullable NSString *)macAddressOf: (nonnull NSString *)ipAddress {
    int sockfd;
    
    sockfd = socket(PF_ROUTE, SOCK_RAW, 0);
    if(sockfd < 0) {
        perror("socket()");
        return nil;
    }//end if
    
    int mib[6];
    size_t needed;
    char *lim, *buf, *newbuf, *next;
    struct rt_msghdr *rtm;
    struct sockaddr_inarp *sin2;
    struct sockaddr_dl *sdl;
    int st;
    
    mib[0] = CTL_NET;
    mib[1] = PF_ROUTE;
    mib[2] = 0;
    mib[3] = AF_INET;
    mib[4] = NET_RT_FLAGS;
#define	RTF_LLINFO	0x400		/* generated by link layer (e.g. ARP) */
    mib[5] = RTF_LLINFO;
    if(sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
        perror("sysctl()");
        close(sockfd);
        return nil;
    }//end if
    
    if(needed == 0) { /* empty table */
        close(sockfd);
        return nil;
    }
    
    buf = NULL;
    for(;;) {
        newbuf = realloc(buf, needed);
        if(newbuf == NULL) {
            perror("realloc()");
            if(buf != NULL) {
                free(buf);
            }//end if
            close(sockfd);
            return nil;
        }//end if
        buf = newbuf;
        st = sysctl(mib, 6, buf, &needed, NULL, 0);
        if(st == 0 || errno != ENOMEM)
            break;
        needed += needed / 8;
    }//end for
    
    NSString *macAddress = nil;
    in_addr_t searchIpAddress = [Address IPv4Pton:ipAddress];
    
    lim = buf + needed;
    for(next = buf; next < lim; next += rtm->rtm_msglen) {
        rtm = (struct rt_msghdr *)next;
        sin2 = (struct sockaddr_inarp *)(rtm + 1);
        sdl = (struct sockaddr_dl *)((char *)sin2 + SA_SIZE(sin2));
        if(searchIpAddress == sin2->sin_addr.s_addr) {
            macAddress = [Address linkLayerNtop:sdl];
            break;
        }//end if found
    }//end for
    free(buf);
    
    close(sockfd);
    return macAddress;
}//end macAddressOf:

@end
